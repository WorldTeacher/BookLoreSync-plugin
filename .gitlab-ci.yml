# included templates
include:
  # semantic-release template
  - component: "$CI_SERVER_FQDN/to-be-continuous/semantic-release/gitlab-ci-semrel@4.0"
    inputs:
      changelog-enabled: true
      auto-release-enabled: true

# secret variables
# (define the variables below in your GitLab group/project variables)
# GITLAB_TOKEN: A GitLab 'project access token' or 'personal access token' with `api`, `read_repository` and `write repository` scopes.
# SEMREL_GPG_SIGNKEY: Path to the GPG signkey exported with `gpg --armor --export-secret-key`.

# your pipeline stages
stages:
  - build
  - test
  - package-build
  - package-test
  - infra
  - deploy
  - acceptance
  - publish
  - infra-prod
  - production

zip-koplugin-release:
  stage: publish
  image: registry.gitlab.com/gitlab-org/cli:latest
  rules:
    - if: "$CI_COMMIT_TAG"
  before_script:
    - apk add --no-cache zip bash git
    # Authenticate glab against your self-hosted instance
    - glab auth login
      --hostname "$CI_SERVER_HOST"
      --job-token "$CI_JOB_TOKEN"
      --api-protocol https
      --git-protocol https
  script:
    - echo "Generating version information from tag $CI_COMMIT_TAG"
    - bash generate-version.sh

    - echo "Creating koplugin release archive"
    - cd "$CI_PROJECT_DIR/bookloresync.koplugin"
    - zip -r "$CI_PROJECT_DIR/bookloresync.koplugin.zip" *.lua
    - cd "$CI_PROJECT_DIR"

    - ls -lah "$CI_PROJECT_DIR/bookloresync.koplugin.zip"

    # Upload the plugin ZIP
    - >
      glab release upload "$CI_COMMIT_TAG"
      "$CI_PROJECT_DIR/bookloresync.koplugin.zip#bookloresync.koplugin.zip#package"
      --use-package-registry
      -R "$CI_PROJECT_PATH"

    # Upload CHANGELOG.md if it exists
    - |
      if [ -f "CHANGELOG.md" ]; then
        echo "Uploading CHANGELOG.md to release"
        glab release upload "$CI_COMMIT_TAG" \
          "CHANGELOG.md#CHANGELOG.md#other" \
          --use-package-registry \
          -R "$CI_PROJECT_PATH"
      fi

  artifacts:
    paths:
      - bookloresync.koplugin.zip
      - CHANGELOG.md

mr-semrel-preview-comment:
  stage: test
  image: node:20-alpine
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
  variables:
    GIT_DEPTH: "0"  # needed so tags/history exist for semantic-release
  before_script:
    - apk add --no-cache git curl jq
    - git fetch --tags --force --prune
  script:
    # 1) Compute next release version (semantic-release dry run)
    - |
      set -euo pipefail

      echo "Running semantic-release dry-run to compute next version…"
      npx --yes semantic-release --dry-run --no-ci 2>&1 | tee semrel.log

      # semantic-release typically prints: "The next release version is X.Y.Z"
      next_version="$(grep -Eo 'next release version is [0-9]+\.[0-9]+\.[0-9]+' -i semrel.log | tail -n1 | awk '{print $NF}' || true)"

      if [ -z "${next_version}" ]; then
        echo "Could not detect next version from semantic-release output."
        next_tag="unknown"
      else
        next_tag="wt-${next_version}"
      fi

      comment_body=$'this MR would create release '"${next_tag}"$'\n\n<!-- semrel-preview-comment -->'

      # 2) Create or update a single MR comment (identified by the marker)
      notes_base="${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/merge_requests/${CI_MERGE_REQUEST_IID}/notes"

      echo "Looking for existing preview comment…"
      existing_note_id="$(
        curl -sS --header "PRIVATE-TOKEN: ${GITLAB_TOKEN}" "${notes_base}?per_page=100" \
          | jq -r 'map(select(.body | contains("semrel-preview-comment")))[0].id // empty'
      )"

      if [ -z "${existing_note_id}" ]; then
        echo "No existing comment found. Creating a new one…"
        curl -sS --fail \
          --header "PRIVATE-TOKEN: ${GITLAB_TOKEN}" \
          --header "Content-Type: application/json" \
          --data "$(jq -n --arg body "${comment_body}" '{body:$body}')" \
          -X POST "${notes_base}" >/dev/null
      else
        echo "Existing comment found (note_id=${existing_note_id}). Updating…"
        curl -sS --fail \
          --header "PRIVATE-TOKEN: ${GITLAB_TOKEN}" \
          --header "Content-Type: application/json" \
          --data "$(jq -n --arg body "${comment_body}" '{body:$body}')" \
          -X PUT "${notes_base}/${existing_note_id}" >/dev/null
      fi

      echo "MR comment is up to date: ${comment_body}"